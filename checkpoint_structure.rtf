{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\csgray\c0;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Checkpoint system goals:\
\
The main goal of the checkpoint system is to make it much easier to test and iterate on manim animations. It opens a preview window of the animations, allow navigating through animations, quickly jumping through animations, and hot reloading animations that have been updated in the source file. \
\
Checkpoint system structure:\
\
Checkpoints contain: \
1. index (animation number)\
2. line_number (the last line where play() was called, so if it\'92s multiple lines, it\'92s the last line)\
3. state: SceneState with mobject copies\
4. caller_locals: Dictionary of local variables (references not yet copies)\
5. animation_info: Details about the animation for replay\
\
Only play() creates checkpoints. The wait() method does not create new checkpoints.\
\
Hot Reloading:\
\
Running 
\f1\fs22 \cf2 \CocoaLigature0 python -m maniml test_simple.py TestSimple runs maniml. This:\
1. Reads test_simple.py into current_code.\
2. Starts a file watcher to check for edits to test_simple.py.\
3. Opens the window.\
5. Sets current_checkpoint = 0.\
4. Plays run_next_animation(current_checkpoint).\
\
The function run_next_animation(current_checkpoint) blocks key interaction during run, uses current_checkpoint, checks the line_number, comments out all code up to and including that line number, sends that code to exec() to execute. If there\'92s code to run it runs the code. If it plays an animation it exits after playing one animation, updates current_checkpoint+=1, stores that animation in checkpoint at the new current_checkpoint. If there\'92s no animation, it exits after running all code. If there\'92s no code it prints(\'92Already at last animation\'92).\
\
The function play_next_animation(current_checkpoint) blocks key interaction during run, uses current_checkpoint, plays the stored animation in animation_info, and updates current_checkpoint+=1.\
\
The right arrow runs right_arrow(current_checkpoint), which:\
1. If there\'92s a next checkpoint, it runs play_next_animation(current_checkpoint).\
2. If there\'92s no next checkpoint it runs run_next_animation(current_checkpoint). \
\
The down arrow runs down_arrow(current_checkpoint), which:\
1. If there\'92s a next checkpoint, it runs jump_to_next_animation(current_checkpoint).\
2. If there\'92s no next checkpoint it runs run_next_animation(current_checkpoint). \
\
The function jump_to_next_animation(current_checkpoint) sets current_checkpoint += 1 and jumps to the new current_checkpoint. \
\
The left arrow and up arrow run jump_to_previous_animation(current_checkpoint).\
\
The function jump_to_previous_animation(current_checkpoint) sets current_checkpoint -= 1 and jumps to the new current_checkpoint. \
\
When the file watcher detects an edit to test_simple.py, it finds the smallest line that\'92s been edited, smallest_line_edit, and the largest line that\'92s been edited, largest_line_edit, and runs edit_checkpoint(smallest_line_edit, largest_line_edit).\
\
The function edit_checkpoint(smallest_line_edit, largest_line_edit) starts with the last checkpoint, and checks whether the checkpoint\'92s line_number is greater than smallest_line_edit, and continues backward until a checkpoint\'92s line_number is less than smallest_line_edit. Then current_checkpoint is set to this checkpoint\'92s index, all checkpoints with indexes greater than this new current_checkpoint are deleted entirely, and then run_next_animation(current_checkpoint) is run until the line_number of the current_checkpoint is greater than largest_line_edit. \
\
\
\
}