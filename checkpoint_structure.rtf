{\rtf1\ansi\ansicpg1252\cocoartf2759
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\csgray\c0;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Checkpoint system goals:\
\
The main goal of the checkpoint system is to make it much easier to test and iterate on manim animations. It opens a preview window of the animations, allow navigating through animations, quickly jumping through animations, and hot reloading animations that have been updated in the source file. \
\
Overview:\
\
When the program runs, it initiates the first checkpoint which is just a plank screen, then runs the first animation and saves a checkpoint.\
\
If we\'92re at the furthest checkpoint, then we can just run the after_current_checkpoint_code. So all we have to do is \
\
\
\
Checkpoint system structure:\
\
Checkpoints contain: \
1. index (animation number)\
2. line_number (the last line where play() was called, so if it\'92s multiple lines, it\'92s the last line)\
3. state: SceneState with mobject copies\
4. animation_info: Details about the animation for replay\
\
Only play() creates checkpoints. The wait() method does not create new checkpoints.\
\
Hot Reloading:\
\
Running 
\f1\fs22 \cf2 \CocoaLigature0 python -m maniml test_simple.py TestSimple runs maniml. This:\
1. Reads test_simple.py into current_code.\
2. Starts a file watcher to check for edits to test_simple.py.\
3. Opens the window.\
5. Sets current_checkpoint = 0.\
4. Plays run_next_animation(current_checkpoint).\
\
The function jump_to_animation(checkpoint) selects all code up to and including the line number, sends it to exec() to run without animation, jumping to the checkpoint. \
\
The function run_next_animation(current_checkpoint) blocks key interaction during run, uses current_checkpoint and checks the line_number. It then runs jump_to_animation(current_checkpoint). It then takes all the code, comments out all code up to and including that line number, sends that code to exec() to execute with animation. If there\'92s code to run it runs the code. If it plays an animation it exits after playing one animation, updates current_checkpoint+=1, stores that animation in checkpoint at the new current_checkpoint. If there\'92s no animation, it exits after running all code. If there\'92s no code it prints(\'92Already at last animation\'92).\
\
The function play_next_animation(current_checkpoint) blocks key interaction during run, uses current_checkpoint, plays the stored animation in animation_info, and updates current_checkpoint+=1.\
\
The right arrow runs right_arrow(current_checkpoint), which runs run_next_animation(current_checkpoint). \
\
The down arrow runs down_arrow(current_checkpoint), which runs jump_to_next_animation(current_checkpoint).\
\
The function jump_to_next_animation(current_checkpoint) sets current_checkpoint += 1, then runs jump_to_animation(current_checkpoint) on the new checkpoint. \
\
The left arrow and up arrow run jump_to_previous_animation(current_checkpoint).\
\
The function jump_to_previous_animation(current_checkpoint) sets current_checkpoint -= 1, then runs jump_to_animation(current_checkpoint) on the new checkpoint. \
\
When the file watcher detects an edit to test_simple.py, it finds the smallest line that\'92s been edited, smallest_line_edit, and the largest line that\'92s been edited, largest_line_edit, and runs edit_checkpoint(current_checkpoint, smallest_line_edit, largest_line_edit).\
\
The function edit_checkpoint(smallest_line_edit, largest_line_edit) starts with the last checkpoint, and checks whether the checkpoint\'92s line_number is greater than smallest_line_edit, and continues backward until a checkpoint\'92s line_number is less than smallest_line_edit. Then current_checkpoint is set to this checkpoint\'92s index, jump_to_animation(current_checkpoint) is run on this new checkpoint, then all checkpoints with indexes greater than this new current_checkpoint are deleted entirely, and then run_next_animation(current_checkpoint) is run until the line_number of the current_checkpoint is greater than largest_line_edit. \
}